v <- rep(colnames(temp[,2]), nrow(temp))
temp<- mutate(temp, dr = v)
colnames(temp) <- c("sp1", "cor","sp2")
subcoc2<-rbind(subcoc2,temp)
remove(temp)
} #resulting dataset contains edge information for network
links<-subcoc2[,c("sp2","sp1","cor")]
colnames(links)<-c("from", "to","weight")
nodes <-as.data.frame(unique(subcoc2[,3]))
colnames(nodes)<-c("id") #final edits to node and edge datasets
nodes<-merge(nodes,attributes,by = c("id"))
nrow(nodes); length(unique(nodes$id))
nrow(links); nrow(unique(links[,c("from", "to")]))
#build the network
g <- graph.data.frame(d=links, vertices=nodes, directed=T)
# Converts the given igraph object to GEXF format and saves it at the given filepath location
#     g: input igraph object to be converted to gexf format
#     filepath: file location where the output gexf file should be saved
#
saveAsGEXF = function(g, filepath="proba.gexf")
{
require(igraph)
require(rgexf)
if(is.null(V(g)$label))
V(g)$label <- as.character(V(g))
if(is.null(E(g)$weight))
E(g)$weight <- rep.int(1, ecount(g))
nodes <- data.frame(cbind(V(g), V(g)$label))
edges <- t(Vectorize(get.edge, vectorize.args='id')(g, 1:ecount(g)))
vAttrNames <- setdiff(list.vertex.attributes(g), "label")
nodesAtt <- data.frame(sapply(vAttrNames, function(attr) sub("&", "&",get.vertex.attribute(g, attr))))
eAttrNames <- setdiff(list.edge.attributes(g), "weight")
edgesAtt <- data.frame(sapply(eAttrNames, function(attr) sub("&", "&",get.edge.attribute(g, attr))))
graphAtt <- sapply(list.graph.attributes(g), function(attr) sub("&", "&",get.graph.attribute(g, attr)))
output <- write.gexf(nodes, edges,
edgesWeight=E(g)$weight,
edgesAtt = edgesAtt,
nodesAtt = nodesAtt,
meta=c(list(creator="Gopalakrishna Palem", description="igraph -> gexf converted file", keywords="igraph, gexf, R, rgexf"), graphAtt))
print(output, filepath, replace=T)
}
saveAsGEXF(g,filepath="C:/Users/mpeipoch/Dropbox/b.mscripts/biofilmMARC/Manuscript/Figures/Network/temp.gexf")
attributes <-read.table("clipboard", header = T, sep = "\t")#ONLY in case need to copy/paste dataset in
data <-read.table("clipboard", header = T, sep = "\t")
#cor fucntion to generate all potential correlations between OTUs
coc<- rcorr(as.matrix(data), type=c("spearman"))
coc$r<-abs(coc$r) #take negatve values out to apply a cutoff of >0.65 Spearman rank correlation
cocr<-as.data.frame(coc$r)
cocp<-as.data.frame(coc$P)
subcoc<-list()
nom<-as.vector(colnames(cocr))
for(i in 1:ncol(cocr)){
subcoc[[i]] <- subset(cocr, cocr[,i] > 0.8 & cocp[,i] < 0.01, select = c(nom[[i]]))
} #this will generate a list of as many elements as OTUs, each element contains a vector with only OTU correlations above the predetermined cutoff (r=0.6 and p-value 0.5 here)
subcoc2<- matrix(0,ncol=3,nrow=0)
subcoc2<-data.frame(subcoc2)
colnames(subcoc2) <- c("sp1", "cor","sp2")
for(i in 1:length(subcoc)){
temp<-as.data.frame(subcoc[[i]])
temp<- setDT(temp, keep.rownames = TRUE)[]
v <- rep(colnames(temp[,2]), nrow(temp))
temp<- mutate(temp, dr = v)
colnames(temp) <- c("sp1", "cor","sp2")
subcoc2<-rbind(subcoc2,temp)
remove(temp)
} #resulting dataset contains edge information for network
links<-subcoc2[,c("sp2","sp1","cor")]
colnames(links)<-c("from", "to","weight")
nodes <-as.data.frame(unique(subcoc2[,3]))
colnames(nodes)<-c("id") #final edits to node and edge datasets
nodes<-merge(nodes,attributes,by = c("id"))
nrow(nodes); length(unique(nodes$id))
nrow(links); nrow(unique(links[,c("from", "to")]))
#build the network
g <- graph.data.frame(d=links, vertices=nodes, directed=T)
# Converts the given igraph object to GEXF format and saves it at the given filepath location
#     g: input igraph object to be converted to gexf format
#     filepath: file location where the output gexf file should be saved
#
saveAsGEXF = function(g, filepath="proba.gexf")
{
require(igraph)
require(rgexf)
if(is.null(V(g)$label))
V(g)$label <- as.character(V(g))
if(is.null(E(g)$weight))
E(g)$weight <- rep.int(1, ecount(g))
nodes <- data.frame(cbind(V(g), V(g)$label))
edges <- t(Vectorize(get.edge, vectorize.args='id')(g, 1:ecount(g)))
vAttrNames <- setdiff(list.vertex.attributes(g), "label")
nodesAtt <- data.frame(sapply(vAttrNames, function(attr) sub("&", "&",get.vertex.attribute(g, attr))))
eAttrNames <- setdiff(list.edge.attributes(g), "weight")
edgesAtt <- data.frame(sapply(eAttrNames, function(attr) sub("&", "&",get.edge.attribute(g, attr))))
graphAtt <- sapply(list.graph.attributes(g), function(attr) sub("&", "&",get.graph.attribute(g, attr)))
output <- write.gexf(nodes, edges,
edgesWeight=E(g)$weight,
edgesAtt = edgesAtt,
nodesAtt = nodesAtt,
meta=c(list(creator="Gopalakrishna Palem", description="igraph -> gexf converted file", keywords="igraph, gexf, R, rgexf"), graphAtt))
print(output, filepath, replace=T)
}
saveAsGEXF(g,filepath="C:/Users/mpeipoch/Dropbox/b.mscripts/biofilmMARC/Manuscript/Figures/Network/temp.gexf")
data <-read.table("clipboard", header = T, sep = "\t")
attributes <-read.table("clipboard", header = T, sep = "\t")#ONLY in case need to copy/paste dataset in
#cor fucntion to generate all potential correlations between OTUs
coc<- rcorr(as.matrix(data), type=c("spearman"))
coc$r<-abs(coc$r) #take negatve values out to apply a cutoff of >0.65 Spearman rank correlation
cocr<-as.data.frame(coc$r)
cocp<-as.data.frame(coc$P)
subcoc<-list()
nom<-as.vector(colnames(cocr))
for(i in 1:ncol(cocr)){
subcoc[[i]] <- subset(cocr, cocr[,i] > 0.8 & cocp[,i] < 0.01, select = c(nom[[i]]))
} #this will generate a list of as many elements as OTUs, each element contains a vector with only OTU correlations above the predetermined cutoff (r=0.6 and p-value 0.5 here)
subcoc2<- matrix(0,ncol=3,nrow=0)
subcoc2<-data.frame(subcoc2)
colnames(subcoc2) <- c("sp1", "cor","sp2")
for(i in 1:length(subcoc)){
temp<-as.data.frame(subcoc[[i]])
temp<- setDT(temp, keep.rownames = TRUE)[]
v <- rep(colnames(temp[,2]), nrow(temp))
temp<- mutate(temp, dr = v)
colnames(temp) <- c("sp1", "cor","sp2")
subcoc2<-rbind(subcoc2,temp)
remove(temp)
} #resulting dataset contains edge information for network
links<-subcoc2[,c("sp2","sp1","cor")]
colnames(links)<-c("from", "to","weight")
nodes <-as.data.frame(unique(subcoc2[,3]))
colnames(nodes)<-c("id") #final edits to node and edge datasets
nodes<-merge(nodes,attributes,by = c("id"))
nrow(nodes); length(unique(nodes$id))
nrow(links); nrow(unique(links[,c("from", "to")]))
#build the network
g <- graph.data.frame(d=links, vertices=nodes, directed=T)
# Converts the given igraph object to GEXF format and saves it at the given filepath location
#     g: input igraph object to be converted to gexf format
#     filepath: file location where the output gexf file should be saved
#
saveAsGEXF = function(g, filepath="proba.gexf")
{
require(igraph)
require(rgexf)
if(is.null(V(g)$label))
V(g)$label <- as.character(V(g))
if(is.null(E(g)$weight))
E(g)$weight <- rep.int(1, ecount(g))
nodes <- data.frame(cbind(V(g), V(g)$label))
edges <- t(Vectorize(get.edge, vectorize.args='id')(g, 1:ecount(g)))
vAttrNames <- setdiff(list.vertex.attributes(g), "label")
nodesAtt <- data.frame(sapply(vAttrNames, function(attr) sub("&", "&",get.vertex.attribute(g, attr))))
eAttrNames <- setdiff(list.edge.attributes(g), "weight")
edgesAtt <- data.frame(sapply(eAttrNames, function(attr) sub("&", "&",get.edge.attribute(g, attr))))
graphAtt <- sapply(list.graph.attributes(g), function(attr) sub("&", "&",get.graph.attribute(g, attr)))
output <- write.gexf(nodes, edges,
edgesWeight=E(g)$weight,
edgesAtt = edgesAtt,
nodesAtt = nodesAtt,
meta=c(list(creator="Gopalakrishna Palem", description="igraph -> gexf converted file", keywords="igraph, gexf, R, rgexf"), graphAtt))
print(output, filepath, replace=T)
}
saveAsGEXF(g,filepath="C:/Users/mpeipoch/Dropbox/b.mscripts/biofilmMARC/Manuscript/Figures/Network/temp.gexf")
data <-read.table("clipboard", header = T, sep = "\t")
attributes <-read.table("clipboard", header = T, sep = "\t")#ONLY in case need to copy/paste dataset in
data <-read.table("clipboard", header = T, sep = "\t")
#cor fucntion to generate all potential correlations between OTUs
coc<- rcorr(as.matrix(data), type=c("spearman"))
coc$r<-abs(coc$r) #take negatve values out to apply a cutoff of >0.65 Spearman rank correlation
cocr<-as.data.frame(coc$r)
cocp<-as.data.frame(coc$P)
subcoc<-list()
nom<-as.vector(colnames(cocr))
for(i in 1:ncol(cocr)){
subcoc[[i]] <- subset(cocr, cocr[,i] > 0.8 & cocp[,i] < 0.01, select = c(nom[[i]]))
} #this will generate a list of as many elements as OTUs, each element contains a vector with only OTU correlations above the predetermined cutoff (r=0.6 and p-value 0.5 here)
subcoc2<- matrix(0,ncol=3,nrow=0)
subcoc2<-data.frame(subcoc2)
colnames(subcoc2) <- c("sp1", "cor","sp2")
for(i in 1:length(subcoc)){
temp<-as.data.frame(subcoc[[i]])
temp<- setDT(temp, keep.rownames = TRUE)[]
v <- rep(colnames(temp[,2]), nrow(temp))
temp<- mutate(temp, dr = v)
colnames(temp) <- c("sp1", "cor","sp2")
subcoc2<-rbind(subcoc2,temp)
remove(temp)
} #resulting dataset contains edge information for network
links<-subcoc2[,c("sp2","sp1","cor")]
colnames(links)<-c("from", "to","weight")
nodes <-as.data.frame(unique(subcoc2[,3]))
colnames(nodes)<-c("id") #final edits to node and edge datasets
nodes<-merge(nodes,attributes,by = c("id"))
nrow(nodes); length(unique(nodes$id))
nrow(links); nrow(unique(links[,c("from", "to")]))
#build the network
g <- graph.data.frame(d=links, vertices=nodes, directed=T)
# Converts the given igraph object to GEXF format and saves it at the given filepath location
#     g: input igraph object to be converted to gexf format
#     filepath: file location where the output gexf file should be saved
#
saveAsGEXF = function(g, filepath="proba.gexf")
{
require(igraph)
require(rgexf)
if(is.null(V(g)$label))
V(g)$label <- as.character(V(g))
if(is.null(E(g)$weight))
E(g)$weight <- rep.int(1, ecount(g))
nodes <- data.frame(cbind(V(g), V(g)$label))
edges <- t(Vectorize(get.edge, vectorize.args='id')(g, 1:ecount(g)))
vAttrNames <- setdiff(list.vertex.attributes(g), "label")
nodesAtt <- data.frame(sapply(vAttrNames, function(attr) sub("&", "&",get.vertex.attribute(g, attr))))
eAttrNames <- setdiff(list.edge.attributes(g), "weight")
edgesAtt <- data.frame(sapply(eAttrNames, function(attr) sub("&", "&",get.edge.attribute(g, attr))))
graphAtt <- sapply(list.graph.attributes(g), function(attr) sub("&", "&",get.graph.attribute(g, attr)))
output <- write.gexf(nodes, edges,
edgesWeight=E(g)$weight,
edgesAtt = edgesAtt,
nodesAtt = nodesAtt,
meta=c(list(creator="Gopalakrishna Palem", description="igraph -> gexf converted file", keywords="igraph, gexf, R, rgexf"), graphAtt))
print(output, filepath, replace=T)
}
saveAsGEXF(g,filepath="C:/Users/mpeipoch/Dropbox/b.mscripts/biofilmMARC/Manuscript/Figures/Network/temp.gexf")
data <-read.table("clipboard", header = T, sep = "\t")
attributes <-read.table("clipboard", header = T, sep = "\t")#ONLY in case need to copy/paste dataset in
#cor fucntion to generate all potential correlations between OTUs
coc<- rcorr(as.matrix(data), type=c("spearman"))
coc$r<-abs(coc$r) #take negatve values out to apply a cutoff of >0.65 Spearman rank correlation
cocr<-as.data.frame(coc$r)
cocp<-as.data.frame(coc$P)
subcoc<-list()
nom<-as.vector(colnames(cocr))
for(i in 1:ncol(cocr)){
subcoc[[i]] <- subset(cocr, cocr[,i] > 0.8 & cocp[,i] < 0.01, select = c(nom[[i]]))
} #this will generate a list of as many elements as OTUs, each element contains a vector with only OTU correlations above the predetermined cutoff (r=0.6 and p-value 0.5 here)
subcoc2<- matrix(0,ncol=3,nrow=0)
subcoc2<-data.frame(subcoc2)
colnames(subcoc2) <- c("sp1", "cor","sp2")
for(i in 1:length(subcoc)){
temp<-as.data.frame(subcoc[[i]])
temp<- setDT(temp, keep.rownames = TRUE)[]
v <- rep(colnames(temp[,2]), nrow(temp))
temp<- mutate(temp, dr = v)
colnames(temp) <- c("sp1", "cor","sp2")
subcoc2<-rbind(subcoc2,temp)
remove(temp)
} #resulting dataset contains edge information for network
links<-subcoc2[,c("sp2","sp1","cor")]
colnames(links)<-c("from", "to","weight")
nodes <-as.data.frame(unique(subcoc2[,3]))
colnames(nodes)<-c("id") #final edits to node and edge datasets
nodes<-merge(nodes,attributes,by = c("id"))
nrow(nodes); length(unique(nodes$id))
nrow(links); nrow(unique(links[,c("from", "to")]))
#build the network
g <- graph.data.frame(d=links, vertices=nodes, directed=T)
# Converts the given igraph object to GEXF format and saves it at the given filepath location
#     g: input igraph object to be converted to gexf format
#     filepath: file location where the output gexf file should be saved
#
saveAsGEXF = function(g, filepath="proba.gexf")
{
require(igraph)
require(rgexf)
if(is.null(V(g)$label))
V(g)$label <- as.character(V(g))
if(is.null(E(g)$weight))
E(g)$weight <- rep.int(1, ecount(g))
nodes <- data.frame(cbind(V(g), V(g)$label))
edges <- t(Vectorize(get.edge, vectorize.args='id')(g, 1:ecount(g)))
vAttrNames <- setdiff(list.vertex.attributes(g), "label")
nodesAtt <- data.frame(sapply(vAttrNames, function(attr) sub("&", "&",get.vertex.attribute(g, attr))))
eAttrNames <- setdiff(list.edge.attributes(g), "weight")
edgesAtt <- data.frame(sapply(eAttrNames, function(attr) sub("&", "&",get.edge.attribute(g, attr))))
graphAtt <- sapply(list.graph.attributes(g), function(attr) sub("&", "&",get.graph.attribute(g, attr)))
output <- write.gexf(nodes, edges,
edgesWeight=E(g)$weight,
edgesAtt = edgesAtt,
nodesAtt = nodesAtt,
meta=c(list(creator="Gopalakrishna Palem", description="igraph -> gexf converted file", keywords="igraph, gexf, R, rgexf"), graphAtt))
print(output, filepath, replace=T)
}
saveAsGEXF(g,filepath="C:/Users/mpeipoch/Dropbox/b.mscripts/biofilmMARC/Manuscript/Figures/Network/temp.gexf")
attributes <-read.table("clipboard", header = T, sep = "\t")#ONLY in case need to copy/paste dataset in
data <-read.table("clipboard", header = T, sep = "\t")
#cor fucntion to generate all potential correlations between OTUs
coc<- rcorr(as.matrix(data), type=c("spearman"))
coc$r<-abs(coc$r) #take negatve values out to apply a cutoff of >0.65 Spearman rank correlation
cocr<-as.data.frame(coc$r)
cocp<-as.data.frame(coc$P)
subcoc<-list()
nom<-as.vector(colnames(cocr))
for(i in 1:ncol(cocr)){
subcoc[[i]] <- subset(cocr, cocr[,i] > 0.8 & cocp[,i] < 0.01, select = c(nom[[i]]))
} #this will generate a list of as many elements as OTUs, each element contains a vector with only OTU correlations above the predetermined cutoff (r=0.6 and p-value 0.5 here)
subcoc2<- matrix(0,ncol=3,nrow=0)
subcoc2<-data.frame(subcoc2)
colnames(subcoc2) <- c("sp1", "cor","sp2")
for(i in 1:length(subcoc)){
temp<-as.data.frame(subcoc[[i]])
temp<- setDT(temp, keep.rownames = TRUE)[]
v <- rep(colnames(temp[,2]), nrow(temp))
temp<- mutate(temp, dr = v)
colnames(temp) <- c("sp1", "cor","sp2")
subcoc2<-rbind(subcoc2,temp)
remove(temp)
} #resulting dataset contains edge information for network
links<-subcoc2[,c("sp2","sp1","cor")]
colnames(links)<-c("from", "to","weight")
nodes <-as.data.frame(unique(subcoc2[,3]))
colnames(nodes)<-c("id") #final edits to node and edge datasets
nodes<-merge(nodes,attributes,by = c("id"))
nrow(nodes); length(unique(nodes$id))
nrow(links); nrow(unique(links[,c("from", "to")]))
#build the network
g <- graph.data.frame(d=links, vertices=nodes, directed=T)
# Converts the given igraph object to GEXF format and saves it at the given filepath location
#     g: input igraph object to be converted to gexf format
#     filepath: file location where the output gexf file should be saved
#
saveAsGEXF = function(g, filepath="proba.gexf")
{
require(igraph)
require(rgexf)
if(is.null(V(g)$label))
V(g)$label <- as.character(V(g))
if(is.null(E(g)$weight))
E(g)$weight <- rep.int(1, ecount(g))
nodes <- data.frame(cbind(V(g), V(g)$label))
edges <- t(Vectorize(get.edge, vectorize.args='id')(g, 1:ecount(g)))
vAttrNames <- setdiff(list.vertex.attributes(g), "label")
nodesAtt <- data.frame(sapply(vAttrNames, function(attr) sub("&", "&",get.vertex.attribute(g, attr))))
eAttrNames <- setdiff(list.edge.attributes(g), "weight")
edgesAtt <- data.frame(sapply(eAttrNames, function(attr) sub("&", "&",get.edge.attribute(g, attr))))
graphAtt <- sapply(list.graph.attributes(g), function(attr) sub("&", "&",get.graph.attribute(g, attr)))
output <- write.gexf(nodes, edges,
edgesWeight=E(g)$weight,
edgesAtt = edgesAtt,
nodesAtt = nodesAtt,
meta=c(list(creator="Gopalakrishna Palem", description="igraph -> gexf converted file", keywords="igraph, gexf, R, rgexf"), graphAtt))
print(output, filepath, replace=T)
}
saveAsGEXF(g,filepath="C:/Users/mpeipoch/Dropbox/b.mscripts/biofilmMARC/Manuscript/Figures/Network/temp.gexf")
data <-read.table("clipboard", header = T, sep = "\t")
attributes <-read.table("clipboard", header = T, sep = "\t")#ONLY in case need to copy/paste dataset in
#cor fucntion to generate all potential correlations between OTUs
coc<- rcorr(as.matrix(data), type=c("spearman"))
coc$r<-abs(coc$r) #take negatve values out to apply a cutoff of >0.65 Spearman rank correlation
cocr<-as.data.frame(coc$r)
cocp<-as.data.frame(coc$P)
subcoc<-list()
nom<-as.vector(colnames(cocr))
for(i in 1:ncol(cocr)){
subcoc[[i]] <- subset(cocr, cocr[,i] > 0.8 & cocp[,i] < 0.01, select = c(nom[[i]]))
} #this will generate a list of as many elements as OTUs, each element contains a vector with only OTU correlations above the predetermined cutoff (r=0.6 and p-value 0.5 here)
subcoc2<- matrix(0,ncol=3,nrow=0)
subcoc2<-data.frame(subcoc2)
colnames(subcoc2) <- c("sp1", "cor","sp2")
for(i in 1:length(subcoc)){
temp<-as.data.frame(subcoc[[i]])
temp<- setDT(temp, keep.rownames = TRUE)[]
v <- rep(colnames(temp[,2]), nrow(temp))
temp<- mutate(temp, dr = v)
colnames(temp) <- c("sp1", "cor","sp2")
subcoc2<-rbind(subcoc2,temp)
remove(temp)
} #resulting dataset contains edge information for network
links<-subcoc2[,c("sp2","sp1","cor")]
colnames(links)<-c("from", "to","weight")
nodes <-as.data.frame(unique(subcoc2[,3]))
colnames(nodes)<-c("id") #final edits to node and edge datasets
nodes<-merge(nodes,attributes,by = c("id"))
nrow(nodes); length(unique(nodes$id))
nrow(links); nrow(unique(links[,c("from", "to")]))
#build the network
g <- graph.data.frame(d=links, vertices=nodes, directed=T)
# Converts the given igraph object to GEXF format and saves it at the given filepath location
#     g: input igraph object to be converted to gexf format
#     filepath: file location where the output gexf file should be saved
#
saveAsGEXF = function(g, filepath="proba.gexf")
{
require(igraph)
require(rgexf)
if(is.null(V(g)$label))
V(g)$label <- as.character(V(g))
if(is.null(E(g)$weight))
E(g)$weight <- rep.int(1, ecount(g))
nodes <- data.frame(cbind(V(g), V(g)$label))
edges <- t(Vectorize(get.edge, vectorize.args='id')(g, 1:ecount(g)))
vAttrNames <- setdiff(list.vertex.attributes(g), "label")
nodesAtt <- data.frame(sapply(vAttrNames, function(attr) sub("&", "&",get.vertex.attribute(g, attr))))
eAttrNames <- setdiff(list.edge.attributes(g), "weight")
edgesAtt <- data.frame(sapply(eAttrNames, function(attr) sub("&", "&",get.edge.attribute(g, attr))))
graphAtt <- sapply(list.graph.attributes(g), function(attr) sub("&", "&",get.graph.attribute(g, attr)))
output <- write.gexf(nodes, edges,
edgesWeight=E(g)$weight,
edgesAtt = edgesAtt,
nodesAtt = nodesAtt,
meta=c(list(creator="Gopalakrishna Palem", description="igraph -> gexf converted file", keywords="igraph, gexf, R, rgexf"), graphAtt))
print(output, filepath, replace=T)
}
saveAsGEXF(g,filepath="C:/Users/mpeipoch/Dropbox/b.mscripts/biofilmMARC/Manuscript/Figures/Network/temp.gexf")
data <-read.table("clipboard", header = T, sep = "\t")
attributes <-read.table("clipboard", header = T, sep = "\t")#ONLY in case need to copy/paste dataset in
data <-read.table("clipboard", header = T, sep = "\t")
#cor fucntion to generate all potential correlations between OTUs
coc<- rcorr(as.matrix(data), type=c("spearman"))
coc$r<-abs(coc$r) #take negatve values out to apply a cutoff of >0.65 Spearman rank correlation
cocr<-as.data.frame(coc$r)
cocp<-as.data.frame(coc$P)
subcoc<-list()
nom<-as.vector(colnames(cocr))
for(i in 1:ncol(cocr)){
subcoc[[i]] <- subset(cocr, cocr[,i] > 0.8 & cocp[,i] < 0.01, select = c(nom[[i]]))
} #this will generate a list of as many elements as OTUs, each element contains a vector with only OTU correlations above the predetermined cutoff (r=0.6 and p-value 0.5 here)
subcoc2<- matrix(0,ncol=3,nrow=0)
subcoc2<-data.frame(subcoc2)
colnames(subcoc2) <- c("sp1", "cor","sp2")
for(i in 1:length(subcoc)){
temp<-as.data.frame(subcoc[[i]])
temp<- setDT(temp, keep.rownames = TRUE)[]
v <- rep(colnames(temp[,2]), nrow(temp))
temp<- mutate(temp, dr = v)
colnames(temp) <- c("sp1", "cor","sp2")
subcoc2<-rbind(subcoc2,temp)
remove(temp)
} #resulting dataset contains edge information for network
links<-subcoc2[,c("sp2","sp1","cor")]
colnames(links)<-c("from", "to","weight")
nodes <-as.data.frame(unique(subcoc2[,3]))
colnames(nodes)<-c("id") #final edits to node and edge datasets
nodes<-merge(nodes,attributes,by = c("id"))
nrow(nodes); length(unique(nodes$id))
nrow(links); nrow(unique(links[,c("from", "to")]))
#build the network
g <- graph.data.frame(d=links, vertices=nodes, directed=T)
# Converts the given igraph object to GEXF format and saves it at the given filepath location
#     g: input igraph object to be converted to gexf format
#     filepath: file location where the output gexf file should be saved
#
saveAsGEXF = function(g, filepath="proba.gexf")
{
require(igraph)
require(rgexf)
if(is.null(V(g)$label))
V(g)$label <- as.character(V(g))
if(is.null(E(g)$weight))
E(g)$weight <- rep.int(1, ecount(g))
nodes <- data.frame(cbind(V(g), V(g)$label))
edges <- t(Vectorize(get.edge, vectorize.args='id')(g, 1:ecount(g)))
vAttrNames <- setdiff(list.vertex.attributes(g), "label")
nodesAtt <- data.frame(sapply(vAttrNames, function(attr) sub("&", "&",get.vertex.attribute(g, attr))))
eAttrNames <- setdiff(list.edge.attributes(g), "weight")
edgesAtt <- data.frame(sapply(eAttrNames, function(attr) sub("&", "&",get.edge.attribute(g, attr))))
graphAtt <- sapply(list.graph.attributes(g), function(attr) sub("&", "&",get.graph.attribute(g, attr)))
output <- write.gexf(nodes, edges,
edgesWeight=E(g)$weight,
edgesAtt = edgesAtt,
nodesAtt = nodesAtt,
meta=c(list(creator="Gopalakrishna Palem", description="igraph -> gexf converted file", keywords="igraph, gexf, R, rgexf"), graphAtt))
print(output, filepath, replace=T)
}
saveAsGEXF(g,filepath="C:/Users/mpeipoch/Dropbox/b.mscripts/biofilmMARC/Manuscript/Figures/Network/temp.gexf")
getwd()
enviro = read.csv("enviro.csv")
summary(enviro)
enviro
View(enviro)
plot(enviro$temperature, enviro$phosphate)
surf_enviro<-enviro
rivers <- c("Swan","Bitterroot","Clark fork","Boulder","Madison","Big Hole","Big Horn", "Tongue", "Missouri", "Milk")
df_list <- split(surf_enviro[,8:19], as.factor(surf_enviro$river))
df_list2 <- matrix(0,ncol=12,nrow=0)
View(df_list)
for (i in 1:length(df_list)){
temp <- scale(df_list[[i]], center = TRUE, scale = TRUE)
df_list2<-rbind(df_list2,temp)
}
df_list2<-as.data.frame(df_list2)
st_data<-cbind(surf_enviro[,1:7],df_list2)
View(stdata)
View(surf_enviro)
View(st_data)
library(fmsb)
install.packages("fmsb")
set.seed(99)
data=as.data.frame(matrix( sample( 0:20 , 15 , replace=F) , ncol=5))
colnames(data)=c("math" , "english" , "biology" , "music" , "R-coding" )
rownames(data)=paste("mister" , letters[1:3] , sep="-")
data
#contains all rivers and  enviro variables standarized
t(st_data)
#contains all rivers and  enviro variables standarized
t<-t(st_data)
#contains all rivers and  enviro variables standarized
t<-as.data.frame(t(st_data))
View(t)
st_data<-cbind(surf_enviro[,c(2,5)],df_list2)
View(st_data)
#contains all rivers and  enviro variables standarized
t<-as.data.frame(t(st_data))
View(t)
#contains all rivers and  enviro variables standarized
write.table(st_data, file = "C:/Users/mpeipoch/Dropbox/b.mscripts/biofilmMARC/Datasets/working datasets/st_data.txt")
data
st_data<-cbind(surf_enviro[,c(2)],df_list2)
#contains all rivers and  enviro variables standarized
st_data_avg<-tapply(st_data,river,mean)
#contains all rivers and  enviro variables standarized
st_data_avg<-tapply(st_data[,2:13],river,mean)
library(plyr)
